<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Serial CANUSB Trace</title>
    <style>
        body { font-family: sans-serif; margin: 20px; line-height: 1.6; }
        button { margin: 5px; padding: 8px 15px; cursor: pointer; }
        button:disabled { cursor: not-allowed; opacity: 0.6; }
        #controls button { margin-bottom: 10px; } /* Add margin below buttons */
        #status { margin: 15px 0; font-weight: bold; }
        #messages { margin-top: 20px; max-height: 60vh; overflow-y: auto; border: 1px solid #ccc; padding: 10px; min-height: 100px; background: #f9f9f9; }
        table { width: 100%; border-collapse: collapse; background: white;}
        th, td { border: 1px solid #ddd; padding: 6px; text-align: left; font-family: monospace; }
        th { background-color: #e2e2e2; }
        .timestamp { font-size: 0.8em; color: #555; }
        .highlight { background-color: #ffffdd !important; }
        .error { color: red; font-weight: bold; }
        .status-connected { color: green; }
        .status-disconnected { color: red; }
        .status-connecting { color: orange; }
        .command-note { font-size: 0.9em; color: #444; margin-top: 15px; }
    </style>
</head>
<body>
    <h1>Web Serial CANUSB Trace (500 kbit/s)</h1>

    <p>Connects to a Lawicel CANUSB adapter via Web Serial API.</p>
    <p><strong>Requires:</strong> Chrome/Edge/Opera, CANUSB VCP drivers installed.</p>

    <div id="controls">
        <button id="connect-btn">Request Port & Connect</button>
        <button id="disconnect-btn" disabled>Disconnect</button>
        <button id="clear-log-btn">Clear Log</button>
        <button id="save-btn">Save Trace</button> {/* <!-- Add Save button --> */}
    </div>

    <div id="status">Status: <span id="status-message" class="status-disconnected">Disconnected</span></div>

    <div id="messages">
        <table>
            <thead>
                <tr>
                    <th>Timestamp</th>
                    <th>Type</th>
                    <th>ID</th>
                    <th>DLC</th>
                    <th>Data</th>
                    <!-- <th>Raw</th> -->
                </tr>
            </thead>
            <tbody id="message-body">
                <!-- Messages will be added here -->
            </tbody>
        </table>
    </div>

    <div class="command-note">
        Configuration: Serial 115200 baud, CAN 500 kbit/s (S6).
    </div>

    <script>
        const connectBtn = document.getElementById('connect-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const clearLogBtn = document.getElementById('clear-log-btn');
        const saveBtn = document.getElementById('save-btn'); // Get save button
        const statusMessage = document.getElementById('status-message');
        const messageBody = document.getElementById('message-body');

        const BAUD_RATE = 115200;
        const CAN_BITRATE_CMD = 'S6'; // 500 kbit/s
        const OPEN_CAN_CMD = 'O';
        const CLOSE_CAN_CMD = 'C';
        const CR = '\r'; // Carriage Return character

        let port;
        let reader;
        let writer;
        let keepReading = false;
        let lineBuffer = '';
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        let maxMessagesInTable = 200; // Limit displayed messages in table
        let loggedMessages = []; // Array to store all messages for saving

        // --- UI Update Functions ---
        function updateStatus(message, connectedState = null) {
            statusMessage.textContent = message;
            console.log("Status:", message); // Log status changes
            if (connectedState === true) {
                statusMessage.className = 'status-connected';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                saveBtn.disabled = false; // Enable save when connected
                clearLogBtn.disabled = false; // Enable clear when connected
            } else if (connectedState === false) {
                statusMessage.className = 'status-disconnected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                 // Keep save/clear enabled if there are messages, disable if empty? Or keep enabled. Let's keep enabled.
                 saveBtn.disabled = (loggedMessages.length === 0);
                 clearLogBtn.disabled = (loggedMessages.length === 0);
            } else { // Intermediate state (connecting...)
                statusMessage.className = 'status-connecting';
                connectBtn.disabled = true;
                disconnectBtn.disabled = true;
                saveBtn.disabled = true;
                clearLogBtn.disabled = true;
            }
        }

        function addMessageToTable(msg) {
            if (!messageBody) return;
            const row = messageBody.insertRow(0);
            row.classList.add('highlight');

            const timeCell = row.insertCell();
            const typeCell = row.insertCell();
            const idCell = row.insertCell();
            const dlcCell = row.insertCell();
            const dataCell = row.insertCell();

            const timestamp = new Date(msg.timestamp);
            timeCell.textContent = timestamp.toLocaleTimeString() + '.' + String(timestamp.getMilliseconds()).padStart(3, '0');
            timeCell.classList.add('timestamp');

            typeCell.textContent = msg.type.toUpperCase();
            idCell.textContent = msg.id || '---';
            dlcCell.textContent = msg.dlc !== null ? msg.dlc : '---';
            dataCell.textContent = msg.data ? msg.data.join(' ') : '---';

            if (msg.type === 'error' || msg.type === 'parse_error') {
                row.classList.add('error');
                dataCell.textContent = msg.raw || msg.message || 'Error';
            }

            setTimeout(() => row.classList.remove('highlight'), 500);

            // Limit the number of rows *in the table display*
            while (messageBody.rows.length > maxMessagesInTable) {
                messageBody.deleteRow(-1);
            }
        }

        function parseCanMessage(rawString) {
            const msg = {
                raw: rawString,
                type: "unknown",
                id: null,
                dlc: null,
                data: [],
                timestamp: Date.now() // Use timestamp when message is *parsed*
            };
            // ... (rest of parsing logic remains the same as before) ...
            if (!rawString || rawString.length < 1) return msg;

            try {
                const msgType = rawString[0];
                const rest = rawString.substring(1);

                if (msgType === 't') { // Standard Frame
                    msg.type = 'can_std';
                    msg.id = rest.substring(0, 3);
                    msg.dlc = parseInt(rest.substring(3, 4), 10);
                    const dataStr = rest.substring(4);
                    if (!isNaN(msg.dlc) && dataStr.length >= msg.dlc * 2) {
                        // Only take expected data length, ignore potential timestamp for now
                        msg.data = (dataStr.substring(0, msg.dlc * 2)).match(/.{1,2}/g) || [];
                    } else {
                        console.warn(`Length issue STD: ${rawString}, DLC: ${msg.dlc}, Data: '${dataStr}'`);
                        msg.data = dataStr.match(/.{1,2}/g) || []; // Attempt parse anyway
                    }
                } else if (msgType === 'T') { // Extended Frame
                    msg.type = 'can_ext';
                    msg.id = rest.substring(0, 8);
                    msg.dlc = parseInt(rest.substring(8, 9), 10);
                    const dataStr = rest.substring(9);
                     if (!isNaN(msg.dlc) && dataStr.length >= msg.dlc * 2) {
                         msg.data = (dataStr.substring(0, msg.dlc * 2)).match(/.{1,2}/g) || [];
                    } else {
                        console.warn(`Length issue EXT: ${rawString}, DLC: ${msg.dlc}, Data: '${dataStr}'`);
                        msg.data = dataStr.match(/.{1,2}/g) || [];
                    }
                } else if (msgType === 'r') { // Standard RTR
                    msg.type = 'rtr_std';
                    msg.id = rest.substring(0, 3);
                    msg.dlc = parseInt(rest.substring(3, 4), 10);
                    msg.data = ['RTR'];
                } else if (msgType === 'R') { // Extended RTR
                    msg.type = 'rtr_ext';
                    msg.id = rest.substring(0, 8);
                    msg.dlc = parseInt(rest.substring(8, 9), 10);
                    msg.data = ['RTR'];
                } else if (msgType === 'F') { // Status flags
                    msg.type = 'status_flags';
                    msg.data = [rest];
                } else if (msgType === 'V') { // Version
                    msg.type = 'version';
                    msg.data = [rest];
                } else if (msgType === 'Z' || msgType === 'z') { // TX Ack
                    msg.type = 'ack';
                    msg.data = ['OK'];
                } else if (rawString === '\x07') { // BELL (Error)
                    msg.type = 'error_response';
                    msg.data = ['BELL (Error)'];
                } else if (rawString === '\r') { // CR (OK)
                    msg.type = 'ok_response';
                     msg.data = ['CR (OK)'];
                } else {
                    msg.type = 'other';
                }

            } catch (e) {
                console.error(`Error parsing message '${rawString}': ${e}`);
                msg.type = 'parse_error';
                msg.message = e.message;
            }
            return msg;
        }


        // --- Web Serial Functions ---

        async function writeToStream(command) {
            // ... (writeToStream function remains the same) ...
            if (!writer) {
                console.error("Writer not available.");
                return;
            }
            const data = encoder.encode(command + CR); // Append CR to commands
            await writer.write(data);
            console.log("Sent:", command);
        }

        async function readLoop() {
            // ... (reader setup remains the same) ...
            if (!port || !port.readable) {
                console.error("Port not readable.");
                keepReading = false;
                return;
            }
            reader = port.readable.getReader();
            console.log("Read loop started.");

            try {
                while (keepReading) {
                    // ... (reading logic remains the same) ...
                     const { value, done } = await reader.read();
                    if (done) {
                        console.log("Reader done.");
                        break;
                    }
                    if (value) {
                        lineBuffer += decoder.decode(value, { stream: true });
                        let lines = lineBuffer.split(CR);
                        lineBuffer = lines.pop();

                        lines.forEach(line => {
                            const trimmedLine = line.trim();
                            if (trimmedLine) {
                                const parsedMsg = parseCanMessage(trimmedLine);
                                // Store *all* relevant parsed messages chronologically
                                if (parsedMsg.type.startsWith('can') || parsedMsg.type.startsWith('rtr') || parsedMsg.type === 'status_flags' || parsedMsg.type.includes('error')) {
                                    loggedMessages.push(parsedMsg); // Add to end for chronological saving
                                    addMessageToTable(parsedMsg); // Add to top of visual table
                                    // Update button states if needed (e.g., enable save/clear)
                                    saveBtn.disabled = false;
                                    clearLogBtn.disabled = false;
                                } else {
                                     console.log("Device Response:", trimmedLine);
                                }
                            } else {
                                console.log("Device Response: CR (OK)");
                            }
                        });

                         if (lineBuffer.includes('\x07')) {
                             console.error("Device Response: BELL (Error)");
                             const bellMsg = parseCanMessage('\x07');
                             loggedMessages.push(bellMsg); // Log BELL error too
                             addMessageToTable(bellMsg);
                             lineBuffer = lineBuffer.replace('\x07', '');
                             saveBtn.disabled = false; // Ensure buttons enabled even on error
                             clearLogBtn.disabled = false;
                         }
                    }
                }
            } catch (error) {
                 // ... (error handling remains the same) ...
                console.error("Error in read loop:", error);
                updateStatus(`Read loop error: ${error.message}`, false);
            } finally {
                // ... (reader release remains the same) ...
                 if (reader) {
                     try { await reader.cancel(); } catch (cancelError) { console.warn("Error cancelling reader:", cancelError); }
                     try { reader.releaseLock(); } catch (releaseError) { console.warn("Error releasing reader lock:", releaseError); }
                     reader = null;
                    console.log("Reader released.");
                }
            }
            // ... (rest of readLoop function remains the same) ...
             console.log("Read loop finished.");
             if (keepReading) {
                 updateStatus("Disconnected (Read loop ended unexpectedly)", false);
                 await disconnect();
             }
        }

        async function connect() {
            // ... (connect function remains largely the same, ensures buttons are updated) ...
            if (!navigator.serial) {
                alert("Web Serial API not supported by your browser. Use Chrome, Edge, or Opera.");
                return;
            }

            updateStatus("Requesting port...", null);

            try {
                port = await navigator.serial.requestPort();
                updateStatus("Port selected, opening...", null);

                await port.open({ baudRate: BAUD_RATE });
                updateStatus("Port open, configuring CAN...", null);

                writer = port.writable.getWriter();

                await new Promise(resolve => setTimeout(resolve, 100));
                await writeToStream(''); // Clear buffer
                await new Promise(resolve => setTimeout(resolve, 50));
                await writeToStream(CAN_BITRATE_CMD); // Set bitrate
                await new Promise(resolve => setTimeout(resolve, 50));
                await writeToStream(OPEN_CAN_CMD); // Open CAN channel
                await new Promise(resolve => setTimeout(resolve, 50));

                updateStatus("Connected (500 kbit/s)", true);
                keepReading = true;
                readLoop();

            } catch (error) {
                // ... (error handling remains the same) ...
                 console.error("Connection failed:", error);
                updateStatus(`Connection failed: ${error.message}`, false);
                if (writer) { try { writer.releaseLock(); writer = null; } catch(e){} }
                if (reader) { try { await reader.cancel(); reader.releaseLock(); reader = null; } catch(e){} }
                if (port && port.readable) { port = null; }
                 else if (port) { try { await port.close(); port = null; } catch(e){} }
            }
        }

        async function disconnect() {
             // ... (disconnect function remains the same, ensures buttons are updated) ...
             keepReading = false;

            if (!port) {
                 updateStatus("Already disconnected", false);
                return;
            }

            updateStatus("Disconnecting...", null);

             if (writer) {
                 try {
                     await writeToStream(CLOSE_CAN_CMD);
                     await new Promise(resolve => setTimeout(resolve, 50));
                 } catch (e) { console.warn("Error sending close command:", e); }
                 finally {
                      try { writer.releaseLock(); } catch (e) { console.warn("Error releasing writer lock:", e); }
                      writer = null; console.log("Writer released.");
                 }
             }

             if (reader) { /* readLoop handles reader cleanup */ }

            try {
                await port.close();
                console.log("Port closed.");
            } catch (error) { console.error("Error closing port:", error); }
            finally {
                 port = null;
                 updateStatus("Disconnected", false);
            }
        }

        // --- Save Functionality ---
        function formatTimestampForFile(timestampMs) {
            const date = new Date(timestampMs);
            // Format as YYYY-MM-DD HH:MM:SS.sss
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}.${String(date.getMilliseconds()).padStart(3, '0')}`;
        }

        function saveDataToFile() {
            if (loggedMessages.length === 0) {
                alert("No messages logged yet to save.");
                saveBtn.disabled = true; // Disable if nothing to save
                return;
            }

            const header = "Timestamp,Type,ID,DLC,Data\n";
            const rows = loggedMessages.map(msg => {
                const timestampStr = formatTimestampForFile(msg.timestamp);
                const typeStr = msg.type.toUpperCase();
                const idStr = msg.id || '';
                const dlcStr = msg.dlc !== null ? msg.dlc : '';
                const dataStr = msg.data ? msg.data.join(' ') : '';
                // Basic CSV escaping: if a field contains a comma, quote the whole field
                const escape = (field) => (String(field).includes(',') ? `"${String(field).replace(/"/g, '""')}"` : field); // Also escape double quotes inside

                return `${escape(timestampStr)},${escape(typeStr)},${escape(idStr)},${escape(dlcStr)},${escape(dataStr)}`;
            }).join('\n');

            const csvContent = header + rows;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            const now = new Date();
            const filename = `can_trace_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}.csv`;
            link.setAttribute("download", filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url); // Clean up

            console.log(`Trace saved to ${filename}`);
            // Optional: provide feedback to user in status area
        }

        // --- Event Listeners ---
        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);

        clearLogBtn.addEventListener('click', () => {
            if (messageBody) messageBody.innerHTML = ''; // Clear the visual table
            loggedMessages = []; // Clear the stored message array
            console.log("Log cleared.");
            // Disable buttons if log is now empty
            saveBtn.disabled = true;
            clearLogBtn.disabled = true;
        });

        saveBtn.addEventListener('click', saveDataToFile); // Add listener for save button

        window.addEventListener('beforeunload', async (event) => {
            if (port) {
                console.log("Page closing, attempting to disconnect...");
                await disconnect();
            }
        });

        // --- Initial State ---
        document.addEventListener('DOMContentLoaded', () => { // Ensure DOM is ready
             if (!navigator.serial) {
                 updateStatus("Web Serial API not supported by this browser.", false);
                 connectBtn.disabled = true;
                 saveBtn.disabled = true; // Disable save initially
                 clearLogBtn.disabled = true; // Disable clear initially
             } else {
                 updateStatus("Disconnected", false); // Initial state
                 saveBtn.disabled = true; // Disable save initially
                 clearLogBtn.disabled = true; // Disable clear initially
             }
        });

    </script>
</body>
</html>